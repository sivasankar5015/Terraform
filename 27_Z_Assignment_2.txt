Create the Variables File
In variables.tf create the following variables: app_label, mysql_tier, wordpress_tier, wordpress_version, mysql_password, and mysql_password. Set these default values:
	app_label: wordpress
	mysql_tier: mysql
	wordpress_tier: frontend
	wordpress_version: wordpress_version
	mysql_password: P4sSw0rd0!

Create the Main file
Create a Kubernetes service resource called mysql_service. Within that resource:

Build a metadata block with the following:
	Set the name argument to wordpress-mysql.
	Add a labels block with the app set to the app_label variable.

Make a spec block, and add these two blocks and associated arguments to it:
	A selector block:
		Set the app argument to use the app_label variable.
		Set the tier argument to use the mysql_tier variable.
	A port block:
		Set the port argument to port 3306.
		Set the type argument to NodePort

Create a Kubernetes deployment resource called mysql_deployment. In there:
	Add a metadata block:
		Set the name argument to wordpress-mysql.
		Add a labels block:
			Set an app argument with a value of app_label.
	Add a spec block with the following:
		Set the replicas to 1.
		Add a selector block:
			Inside of that, create a match_labels block with the following arguments:
				Set app to use the app_label variable.
				Set tier to use the mysql_tier variable.
		Create a template block with these other additions:
			A metadata block:
				In here, create a labels block, with these arguments:
					app set to the app_label variable
					tier set to the mysql_tier variable
			A spec block with:
				A container block containing:
					The name argument set to mysql.
					The image argument set to mysql:5.7
					Create an environment variable for MYSQL_ROOT_PASSWORD and set the value to the variable 	.
				Create a port block with the following arguments:
					container_port set to 3306
					name set to mysql

Create a Kubernetes service resource called wordpress_service:
	Add a metadata block:
		Set the name argument to wordpress.
		Add a labels block with the app set to the app_label variable.
	Add a spec block with the following:
		A selector block with these settings:
			Set the app argument to use the app_label variable.
			Set the tier argument to use the mysql_tier variable.
		A port block with these settings:
			Set the port argument to port 80.
			Set the target_port argument to port 80.
			Set the node_port argument to port 8080.
		Set the spec block's type argument to NodePort.

Create a Kubernetes deployment resource called wordpress_deployment:
	Add a metadata block:
		Set the name argument to wordpress.
	Add a spec block with these settings:
		Set the replicas to 1.
		Add a selector block with:
			A match_labels block having the following arguments:
				Set the app argument to use the app_label variable.
				Set the tier argument to use the wordpress_tier variable.
		Add template block containing:
			A metadata block with:
				A labels block having the following arguments:
					app set to the app_label variable
					tier set to the wordpress_tier variable
			A spec block with a container block containing:
				The name argument set to wordpress
				The image argument set to wordpress:
					The tag will be set using the wordpress_version variable with -apache appended to the end of it.
					Create an environment variable for WORDPRESS_DB_HOST and set the value to the variable wordpress-mysql.
					Create another environment variable for WORDPRESS_DB_PASSWORD and set the value to the variable mysql_password.
					Create a port block with the following arguments:
						container_port set to 80
						name set to wordpress


Deploy the infrastructure
	Initialize Terraform.
	Validate the files.
	Deploy the infrastructure.


=======================================================================
=======================================================================


master $ cat variables.tf
#Define variables
variable "app_label" {
  description = "Name of the app label."
  default     = "wordpress"
}
variable "mysql_tier" {
  description = "This is mysql tier desc"
  default     = "mysql"
}
variable "wordpress_tier" {
  description = "This is wordpress_tier desc."
  default     = "frontend"
}
variable "wordpress_version" {
  description = "This is wordpress_version desc"
  default     = "wordpress:latest"
}
variable "mysql_password" {
  description = "This is mysql_password pass desc."
  default     = "P4sSw0rd0!"
}

variable "wordpress-mysql" {
  description = "This is wordpress-mysql desc."
  default     = "wordpress-mysql"
}







#Creating service as wordpress_service
resource "kubernetes_service" "wordpress_service" {
  metadata {
    name = "wordpress"
    labels = {
      app = var.app_label
    }
  }
  spec {
    selector = {
      app = var.app_label
      tier = var.wordpress_tier
    }
    port {
      port        = "80"
      target_port = "80"
      node_port   = "30080"
    }

    type = "NodePort"
  }
}


#Creating deployment as  wordpress_deployment
resource "kubernetes_deployment" "wordpress_deployment" {
  metadata {
    name = "wordpress"
  }

  spec {
    replicas = "1"

    selector  {
      match_labels = {
        app = var.app_label
        tier = var.wordpress_tier
      }
    }

    template {
      metadata {
        labels = {
          app = var.app_label
          tier = var.wordpress_tier
        }
      }

      spec {
        container {
          name  = "wordpress"
          image = var.wordpress_version

          env  {
                name = "WORDPRESS_DB_HOST"
                value = var.wordpress-mysql
          }

         env {
                name = "WORDPRESS_DB_PASSWORD"
                value  = var.mysql_password
          }

          port {
            container_port = "80"
            name = "wordpress"
          }
        }
      }
    }
  }
}




#Creating service as mysql_service
resource "kubernetes_service" "mysql_service" {
  metadata {
    name = "wordpress-mysql"
    labels = {
      app = var.app_label
    }
  }
  spec {
    selector = {
      app = var.app_label
      tier = var.mysql_tier
    }
    port {
      port = "3306"
    }

    type = "NodePort"
  }
}

#Creating deployment as  mysql_deployment
resource "kubernetes_deployment" "mysql_deployment" {
  metadata {
    name = "wordpress-mysql"
     labels = {
      app = var.app_label
  }
}

  spec {
    replicas = "1"

    selector  {
      match_labels = {
        app = var.app_label
        tier = var.mysql_tier
      }
    }

    template {
      metadata {
        labels = {
          app = var.app_label
          tier = var.mysql_tier
        }
      }

      spec {
        container {
          name  = "mysql"
          image = "mysql:5.7"

          env {
              name = "MYSQL_ROOT_PASSWORD"
              value = var.mysql_password
          }

          port {
            container_port = "3306"
            name = "mysql"
          }
        }
      }
    }
  }
}

#Creating service as wordpress_service
resource "kubernetes_service" "wordpress_service" {
  metadata {
    name = "wordpress"
    labels = {
      app = var.app_label
    }
  }
  spec {
    selector = {
      app = var.app_label
      tier = var.wordpress_tier
    }
    port {
      port        = "80"
      target_port = "80"
      node_port   = "30080"
    }

    type = "NodePort"
  }
}


#Creating deployment as  wordpress_deployment
resource "kubernetes_deployment" "wordpress_deployment" {
  metadata {
    name = "wordpress"
  }

  spec {
    replicas = "1"

    selector  {
      match_labels = {
        app = var.app_label
        tier = var.wordpress_tier
      }
    }

    template {
      metadata {
        labels = {
          app = var.app_label
          tier = var.wordpress_tier
        }
      }

      spec {
        container {
          name  = "wordpress"
          image = var.wordpress_version

          env  {
                name = "WORDPRESS_DB_HOST"
                value = var.wordpress-mysql
          }

         env {
                name = "WORDPRESS_DB_PASSWORD"
                value  = var.mysql_password
          }

          port {
            container_port = "80"
            name = "wordpress"
          }
        }
      }
    }
  }
}


master $ terraform init

Initializing the backend...

Initializing provider plugins...
- Checking for available provider plugins...
- Downloading plugin for provider "kubernetes" (hashicorp/kubernetes) 1.10.0...

Terraform has been successfully initialized!

master $ terraform validate
Success! The configuration is valid.

master $ terraform plan
Refreshing Terraform state in-memory prior to plan...
The refreshed state will be used to calculate this plan, but will not be
persisted to local or remote state storage.


------------------------------------------------------------------------

An execution plan has been generated and is shown below.
Resource actions are indicated with the following symbols:
  + create

Terraform will perform the following actions:

  # kubernetes_deployment.mysql_deployment will be created
  + resource "kubernetes_deployment" "mysql_deployment" {
      + id = (known after apply)

      + metadata {
          + generation       = (known after apply)
          + labels           = {
              + "app" = "wordpress"
            }
          + name             = "wordpress-mysql"
          + namespace        = "default"
          + resource_version = (known after apply)
          + self_link        = (known after apply)
          + uid              = (known after apply)
        }

      + spec {
          + min_ready_seconds         = 0
          + paused                    = false
          + progress_deadline_seconds = 600
          + replicas                  = 1
          + revision_history_limit    = 10

          + selector {
              + match_labels = {
                  + "app"  = "wordpress"
                  + "tier" = "mysql"
                }
            }

          + strategy {
              + type = (known after apply)

              + rolling_update {
                  + max_surge       = (known after apply)
                  + max_unavailable = (known after apply)
                }
            }

          + template {
              + metadata {
                  + generation       = (known after apply)
                  + labels           = {
                      + "app"  = "wordpress"
                      + "tier" = "mysql"
                    }
                  + name             = (known after apply)
                  + resource_version = (known after apply)
                  + self_link        = (known after apply)
                  + uid              = (known after apply)
                }

              + spec {
                  + dns_policy                       = "ClusterFirst"
                  + host_ipc                         = false
                  + host_network                     = false
                  + host_pid                         = false
                  + hostname                         = (known after apply)
                  + node_name                        = (known after apply)
                  + restart_policy                   = "Always"
                  + service_account_name             = (known after apply)
                  + share_process_namespace          = false
                  + termination_grace_period_seconds = 30

                  + container {
                      + image                    = "mysql:5.7"
                      + image_pull_policy        = (known after apply)
                      + name                     = "mysql"
                      + stdin                    = false
                      + stdin_once               = false
                      + termination_message_path = "/dev/termination-log"
                      + tty                      = false

                      + env {
                          + name  = "MYSQL_ROOT_PASSWORD"
                          + value = "P4sSw0rd0!"
                        }

                      + port {
                          + container_port = 3306
                          + name           = "mysql"
                          + protocol       = "TCP"
                        }

                      + resources {
                          + limits {
                              + cpu    = (known after apply)
                              + memory = (known after apply)
                            }

                          + requests {
                              + cpu    = (known after apply)
                              + memory = (known after apply)
                            }
                        }

                      + volume_mount {
                          + mount_path        = (known after apply)
                          + mount_propagation = (known after apply)
                          + name              = (known after apply)
                          + read_only         = (known after apply)
                          + sub_path          = (known after apply)
                        }
                    }

                  + image_pull_secrets {
                      + name = (known after apply)
                    }

                  + volume {
                      + name = (known after apply)

                      + aws_elastic_block_store {
                          + fs_type   = (known after apply)
                          + partition = (known after apply)
                          + read_only = (known after apply)
                          + volume_id = (known after apply)
                        }

                      + azure_disk {
                          + caching_mode  = (known after apply)
                          + data_disk_uri = (known after apply)
                          + disk_name     = (known after apply)
                          + fs_type       = (known after apply)
                          + read_only     = (known after apply)
                        }

                      + azure_file {
                          + read_only   = (known after apply)
                          + secret_name = (known after apply)
                          + share_name  = (known after apply)
                        }

                      + ceph_fs {
                          + monitors    = (known after apply)
                          + path        = (known after apply)
                          + read_only   = (known after apply)
                          + secret_file = (known after apply)
                          + user        = (known after apply)

                          + secret_ref {
                              + name = (known after apply)
                            }
                        }

                      + cinder {
                          + fs_type   = (known after apply)
                          + read_only = (known after apply)
                          + volume_id = (known after apply)
                        }

                      + config_map {
                          + default_mode = (known after apply)
                          + name         = (known after apply)

                          + items {
                              + key  = (known after apply)
                              + mode = (known after apply)
                              + path = (known after apply)
                            }
                        }

                      + downward_api {
                          + default_mode = (known after apply)

                          + items {
                              + mode = (known after apply)
                              + path = (known after apply)

                              + field_ref {
                                  + api_version = (known after apply)
                                  + field_path  = (known after apply)
                                }

                              + resource_field_ref {
                                  + container_name = (known after apply)
                                  + quantity       = (known after apply)
                                  + resource       = (known after apply)
                                }
                            }
                        }

                      + empty_dir {
                          + medium = (known after apply)
                        }

                      + fc {
                          + fs_type      = (known after apply)
                          + lun          = (known after apply)
                          + read_only    = (known after apply)
                          + target_ww_ns = (known after apply)
                        }

                      + flex_volume {
                          + driver    = (known after apply)
                          + fs_type   = (known after apply)
                          + options   = (known after apply)
                          + read_only = (known after apply)

                          + secret_ref {
                              + name = (known after apply)
                            }
                        }

                      + flocker {
                          + dataset_name = (known after apply)
                          + dataset_uuid = (known after apply)
                        }

                      + gce_persistent_disk {
                          + fs_type   = (known after apply)
                          + partition = (known after apply)
                          + pd_name   = (known after apply)
                          + read_only = (known after apply)
                        }

                      + git_repo {
                          + directory  = (known after apply)
                          + repository = (known after apply)
                          + revision   = (known after apply)
                        }

                      + glusterfs {
                          + endpoints_name = (known after apply)
                          + path           = (known after apply)
                          + read_only      = (known after apply)
                        }

                      + host_path {
                          + path = (known after apply)
                          + type = (known after apply)
                        }

                      + iscsi {
                          + fs_type         = (known after apply)
                          + iqn             = (known after apply)
                          + iscsi_interface = (known after apply)
                          + lun             = (known after apply)
                          + read_only       = (known after apply)
                          + target_portal   = (known after apply)
                        }

                      + local {
                          + path = (known after apply)
                        }

                      + nfs {
                          + path      = (known after apply)
                          + read_only = (known after apply)
                          + server    = (known after apply)
                        }

                      + persistent_volume_claim {
                          + claim_name = (known after apply)
                          + read_only  = (known after apply)
                        }

                      + photon_persistent_disk {
                          + fs_type = (known after apply)
                          + pd_id   = (known after apply)
                        }

                      + quobyte {
                          + group     = (known after apply)
                          + read_only = (known after apply)
                          + registry  = (known after apply)
                          + user      = (known after apply)
                          + volume    = (known after apply)
                        }

                      + rbd {
                          + ceph_monitors = (known after apply)
                          + fs_type       = (known after apply)
                          + keyring       = (known after apply)
                          + rados_user    = (known after apply)
                          + rbd_image     = (known after apply)
                          + rbd_pool      = (known after apply)
                          + read_only     = (known after apply)

                          + secret_ref {
                              + name = (known after apply)
                            }
                        }

                      + secret {
                          + default_mode = (known after apply)
                          + optional     = (known after apply)
                          + secret_name  = (known after apply)

                          + items {
                              + key  = (known after apply)
                              + mode = (known after apply)
                              + path = (known after apply)
                            }
                        }

                      + vsphere_volume {
                          + fs_type     = (known after apply)
                          + volume_path = (known after apply)
                        }
                    }
                }
            }
        }
    }

  # kubernetes_deployment.wordpress_deployment will be created
  + resource "kubernetes_deployment" "wordpress_deployment" {
      + id = (known after apply)

      + metadata {
          + generation       = (known after apply)
          + name             = "wordpress"
          + namespace        = "default"
          + resource_version = (known after apply)
          + self_link        = (known after apply)
          + uid              = (known after apply)
        }

      + spec {
          + min_ready_seconds         = 0
          + paused                    = false
          + progress_deadline_seconds = 600
          + replicas                  = 1
          + revision_history_limit    = 10

          + selector {
              + match_labels = {
                  + "app"  = "wordpress"
                  + "tier" = "frontend"
                }
            }

          + strategy {
              + type = (known after apply)

              + rolling_update {
                  + max_surge       = (known after apply)
                  + max_unavailable = (known after apply)
                }
            }

          + template {
              + metadata {
                  + generation       = (known after apply)
                  + labels           = {
                      + "app"  = "wordpress"
                      + "tier" = "frontend"
                    }
                  + name             = (known after apply)
                  + resource_version = (known after apply)
                  + self_link        = (known after apply)
                  + uid              = (known after apply)
                }

              + spec {
                  + dns_policy                       = "ClusterFirst"
                  + host_ipc                         = false
                  + host_network                     = false
                  + host_pid                         = false
                  + hostname                         = (known after apply)
                  + node_name                        = (known after apply)
                  + restart_policy                   = "Always"
                  + service_account_name             = (known after apply)
                  + share_process_namespace          = false
                  + termination_grace_period_seconds = 30

                  + container {
                      + image                    = "wordpress:latest"
                      + image_pull_policy        = (known after apply)
                      + name                     = "wordpress"
                      + stdin                    = false
                      + stdin_once               = false
                      + termination_message_path = "/dev/termination-log"
                      + tty                      = false

                      + env {
                          + name  = "WORDPRESS_DB_HOST"
                          + value = "wordpress-mysql"
                        }
                      + env {
                          + name  = "WORDPRESS_DB_PASSWORD"
                          + value = "P4sSw0rd0!"
                        }

                      + port {
                          + container_port = 80
                          + name           = "wordpress"
                          + protocol       = "TCP"
                        }

                      + resources {
                          + limits {
                              + cpu    = (known after apply)
                              + memory = (known after apply)
                            }

                          + requests {
                              + cpu    = (known after apply)
                              + memory = (known after apply)
                            }
                        }

                      + volume_mount {
                          + mount_path        = (known after apply)
                          + mount_propagation = (known after apply)
                          + name              = (known after apply)
                          + read_only         = (known after apply)
                          + sub_path          = (known after apply)
                        }
                    }

                  + image_pull_secrets {
                      + name = (known after apply)
                    }

                  + volume {
                      + name = (known after apply)

                      + aws_elastic_block_store {
                          + fs_type   = (known after apply)
                          + partition = (known after apply)
                          + read_only = (known after apply)
                          + volume_id = (known after apply)
                        }

                      + azure_disk {
                          + caching_mode  = (known after apply)
                          + data_disk_uri = (known after apply)
                          + disk_name     = (known after apply)
                          + fs_type       = (known after apply)
                          + read_only     = (known after apply)
                        }

                      + azure_file {
                          + read_only   = (known after apply)
                          + secret_name = (known after apply)
                          + share_name  = (known after apply)
                        }

                      + ceph_fs {
                          + monitors    = (known after apply)
                          + path        = (known after apply)
                          + read_only   = (known after apply)
                          + secret_file = (known after apply)
                          + user        = (known after apply)

                          + secret_ref {
                              + name = (known after apply)
                            }
                        }

                      + cinder {
                          + fs_type   = (known after apply)
                          + read_only = (known after apply)
                          + volume_id = (known after apply)
                        }

                      + config_map {
                          + default_mode = (known after apply)
                          + name         = (known after apply)

                          + items {
                              + key  = (known after apply)
                              + mode = (known after apply)
                              + path = (known after apply)
                            }
                        }

                      + downward_api {
                          + default_mode = (known after apply)

                          + items {
                              + mode = (known after apply)
                              + path = (known after apply)

                              + field_ref {
                                  + api_version = (known after apply)
                                  + field_path  = (known after apply)
                                }

                              + resource_field_ref {
                                  + container_name = (known after apply)
                                  + quantity       = (known after apply)
                                  + resource       = (known after apply)
                                }
                            }
                        }

                      + empty_dir {
                          + medium = (known after apply)
                        }

                      + fc {
                          + fs_type      = (known after apply)
                          + lun          = (known after apply)
                          + read_only    = (known after apply)
                          + target_ww_ns = (known after apply)
                        }

                      + flex_volume {
                          + driver    = (known after apply)
                          + fs_type   = (known after apply)
                          + options   = (known after apply)
                          + read_only = (known after apply)

                          + secret_ref {
                              + name = (known after apply)
                            }
                        }

                      + flocker {
                          + dataset_name = (known after apply)
                          + dataset_uuid = (known after apply)
                        }

                      + gce_persistent_disk {
                          + fs_type   = (known after apply)
                          + partition = (known after apply)
                          + pd_name   = (known after apply)
                          + read_only = (known after apply)
                        }

                      + git_repo {
                          + directory  = (known after apply)
                          + repository = (known after apply)
                          + revision   = (known after apply)
                        }

                      + glusterfs {
                          + endpoints_name = (known after apply)
                          + path           = (known after apply)
                          + read_only      = (known after apply)
                        }

                      + host_path {
                          + path = (known after apply)
                          + type = (known after apply)
                        }

                      + iscsi {
                          + fs_type         = (known after apply)
                          + iqn             = (known after apply)
                          + iscsi_interface = (known after apply)
                          + lun             = (known after apply)
                          + read_only       = (known after apply)
                          + target_portal   = (known after apply)
                        }

                      + local {
                          + path = (known after apply)
                        }

                      + nfs {
                          + path      = (known after apply)
                          + read_only = (known after apply)
                          + server    = (known after apply)
                        }

                      + persistent_volume_claim {
                          + claim_name = (known after apply)
                          + read_only  = (known after apply)
                        }

                      + photon_persistent_disk {
                          + fs_type = (known after apply)
                          + pd_id   = (known after apply)
                        }

                      + quobyte {
                          + group     = (known after apply)
                          + read_only = (known after apply)
                          + registry  = (known after apply)
                          + user      = (known after apply)
                          + volume    = (known after apply)
                        }

                      + rbd {
                          + ceph_monitors = (known after apply)
                          + fs_type       = (known after apply)
                          + keyring       = (known after apply)
                          + rados_user    = (known after apply)
                          + rbd_image     = (known after apply)
                          + rbd_pool      = (known after apply)
                          + read_only     = (known after apply)

                          + secret_ref {
                              + name = (known after apply)
                            }
                        }

                      + secret {
                          + default_mode = (known after apply)
                          + optional     = (known after apply)
                          + secret_name  = (known after apply)

                          + items {
                              + key  = (known after apply)
                              + mode = (known after apply)
                              + path = (known after apply)
                            }
                        }

                      + vsphere_volume {
                          + fs_type     = (known after apply)
                          + volume_path = (known after apply)
                        }
                    }
                }
            }
        }
    }

  # kubernetes_service.mysql_service will be created
  + resource "kubernetes_service" "mysql_service" {
      + id                    = (known after apply)
      + load_balancer_ingress = (known after apply)

      + metadata {
          + generation       = (known after apply)
          + labels           = {
              + "app" = "wordpress"
            }
          + name             = "wordpress-mysql"
          + namespace        = "default"
          + resource_version = (known after apply)
          + self_link        = (known after apply)
          + uid              = (known after apply)
        }

      + spec {
          + cluster_ip                  = (known after apply)
          + external_traffic_policy     = (known after apply)
          + publish_not_ready_addresses = false
          + selector                    = {
              + "app"  = "wordpress"
              + "tier" = "mysql"
            }
          + session_affinity            = "None"
          + type                        = "NodePort"

          + port {
              + node_port   = (known after apply)
              + port        = 3306
              + protocol    = "TCP"
              + target_port = (known after apply)
            }
        }
    }

  # kubernetes_service.wordpress_service will be created
  + resource "kubernetes_service" "wordpress_service" {
      + id                    = (known after apply)
      + load_balancer_ingress = (known after apply)

      + metadata {
          + generation       = (known after apply)
          + labels           = {
              + "app" = "wordpress"
            }
          + name             = "wordpress"
          + namespace        = "default"
          + resource_version = (known after apply)
          + self_link        = (known after apply)
          + uid              = (known after apply)
        }

      + spec {
          + cluster_ip                  = (known after apply)
          + external_traffic_policy     = (known after apply)
          + publish_not_ready_addresses = false
          + selector                    = {
              + "app"  = "wordpress"
              + "tier" = "frontend"
            }
          + session_affinity            = "None"
          + type                        = "NodePort"

          + port {
              + node_port   = 30080
              + port        = 80
              + protocol    = "TCP"
              + target_port = "80"
            }
        }
    }

Plan: 4 to add, 0 to change, 0 to destroy.

------------------------------------------------------------------------

Note: You didn't specify an "-out" parameter to save this plan, so Terraform
can't guarantee that exactly these actions will be performed if
"terraform apply" is subsequently run.


master $ terraform apply

An execution plan has been generated and is shown below.
Resource actions are indicated with the following symbols:
  + create

Terraform will perform the following actions:

  # kubernetes_deployment.mysql_deployment will be created
  + resource "kubernetes_deployment" "mysql_deployment" {
      + id = (known after apply)

      + metadata {
          + generation       = (known after apply)
          + labels           = {
              + "app" = "wordpress"
            }
          + name             = "wordpress-mysql"
          + namespace        = "default"
          + resource_version = (known after apply)
          + self_link        = (known after apply)
          + uid              = (known after apply)
        }

      + spec {
          + min_ready_seconds         = 0
          + paused                    = false
          + progress_deadline_seconds = 600
          + replicas                  = 1
          + revision_history_limit    = 10

          + selector {
              + match_labels = {
                  + "app"  = "wordpress"
                  + "tier" = "mysql"
                }
            }

          + strategy {
              + type = (known after apply)

              + rolling_update {
                  + max_surge       = (known after apply)
                  + max_unavailable = (known after apply)
                }
            }

          + template {
              + metadata {
                  + generation       = (known after apply)
                  + labels           = {
                      + "app"  = "wordpress"
                      + "tier" = "mysql"
                    }
                  + name             = (known after apply)
                  + resource_version = (known after apply)
                  + self_link        = (known after apply)
                  + uid              = (known after apply)
                }

              + spec {
                  + dns_policy                       = "ClusterFirst"
                  + host_ipc                         = false
                  + host_network                     = false
                  + host_pid                         = false
                  + hostname                         = (known after apply)
                  + node_name                        = (known after apply)
                  + restart_policy                   = "Always"
                  + service_account_name             = (known after apply)
                  + share_process_namespace          = false
                  + termination_grace_period_seconds = 30

                  + container {
                      + image                    = "mysql:5.7"
                      + image_pull_policy        = (known after apply)
                      + name                     = "mysql"
                      + stdin                    = false
                      + stdin_once               = false
                      + termination_message_path = "/dev/termination-log"
                      + tty                      = false

                      + env {
                          + name  = "MYSQL_ROOT_PASSWORD"
                          + value = "P4sSw0rd0!"
                        }

                      + port {
                          + container_port = 3306
                          + name           = "mysql"
                          + protocol       = "TCP"
                        }

                      + resources {
                          + limits {
                              + cpu    = (known after apply)
                              + memory = (known after apply)
                            }

                          + requests {
                              + cpu    = (known after apply)
                              + memory = (known after apply)
                            }
                        }

                      + volume_mount {
                          + mount_path        = (known after apply)
                          + mount_propagation = (known after apply)
                          + name              = (known after apply)
                          + read_only         = (known after apply)
                          + sub_path          = (known after apply)
                        }
                    }

                  + image_pull_secrets {
                      + name = (known after apply)
                    }

                  + volume {
                      + name = (known after apply)

                      + aws_elastic_block_store {
                          + fs_type   = (known after apply)
                          + partition = (known after apply)
                          + read_only = (known after apply)
                          + volume_id = (known after apply)
                        }

                      + azure_disk {
                          + caching_mode  = (known after apply)
                          + data_disk_uri = (known after apply)
                          + disk_name     = (known after apply)
                          + fs_type       = (known after apply)
                          + read_only     = (known after apply)
                        }

                      + azure_file {
                          + read_only   = (known after apply)
                          + secret_name = (known after apply)
                          + share_name  = (known after apply)
                        }

                      + ceph_fs {
                          + monitors    = (known after apply)
                          + path        = (known after apply)
                          + read_only   = (known after apply)
                          + secret_file = (known after apply)
                          + user        = (known after apply)

                          + secret_ref {
                              + name = (known after apply)
                            }
                        }

                      + cinder {
                          + fs_type   = (known after apply)
                          + read_only = (known after apply)
                          + volume_id = (known after apply)
                        }

                      + config_map {
                          + default_mode = (known after apply)
                          + name         = (known after apply)

                          + items {
                              + key  = (known after apply)
                              + mode = (known after apply)
                              + path = (known after apply)
                            }
                        }

                      + downward_api {
                          + default_mode = (known after apply)

                          + items {
                              + mode = (known after apply)
                              + path = (known after apply)

                              + field_ref {
                                  + api_version = (known after apply)
                                  + field_path  = (known after apply)
                                }

                              + resource_field_ref {
                                  + container_name = (known after apply)
                                  + quantity       = (known after apply)
                                  + resource       = (known after apply)
                                }
                            }
                        }

                      + empty_dir {
                          + medium = (known after apply)
                        }

                      + fc {
                          + fs_type      = (known after apply)
                          + lun          = (known after apply)
                          + read_only    = (known after apply)
                          + target_ww_ns = (known after apply)
                        }

                      + flex_volume {
                          + driver    = (known after apply)
                          + fs_type   = (known after apply)
                          + options   = (known after apply)
                          + read_only = (known after apply)

                          + secret_ref {
                              + name = (known after apply)
                            }
                        }

                      + flocker {
                          + dataset_name = (known after apply)
                          + dataset_uuid = (known after apply)
                        }

                      + gce_persistent_disk {
                          + fs_type   = (known after apply)
                          + partition = (known after apply)
                          + pd_name   = (known after apply)
                          + read_only = (known after apply)
                        }

                      + git_repo {
                          + directory  = (known after apply)
                          + repository = (known after apply)
                          + revision   = (known after apply)
                        }

                      + glusterfs {
                          + endpoints_name = (known after apply)
                          + path           = (known after apply)
                          + read_only      = (known after apply)
                        }

                      + host_path {
                          + path = (known after apply)
                          + type = (known after apply)
                        }

                      + iscsi {
                          + fs_type         = (known after apply)
                          + iqn             = (known after apply)
                          + iscsi_interface = (known after apply)
                          + lun             = (known after apply)
                          + read_only       = (known after apply)
                          + target_portal   = (known after apply)
                        }

                      + local {
                          + path = (known after apply)
                        }

                      + nfs {
                          + path      = (known after apply)
                          + read_only = (known after apply)
                          + server    = (known after apply)
                        }

                      + persistent_volume_claim {
                          + claim_name = (known after apply)
                          + read_only  = (known after apply)
                        }

                      + photon_persistent_disk {
                          + fs_type = (known after apply)
                          + pd_id   = (known after apply)
                        }

                      + quobyte {
                          + group     = (known after apply)
                          + read_only = (known after apply)
                          + registry  = (known after apply)
                          + user      = (known after apply)
                          + volume    = (known after apply)
                        }

                      + rbd {
                          + ceph_monitors = (known after apply)
                          + fs_type       = (known after apply)
                          + keyring       = (known after apply)
                          + rados_user    = (known after apply)
                          + rbd_image     = (known after apply)
                          + rbd_pool      = (known after apply)
                          + read_only     = (known after apply)

                          + secret_ref {
                              + name = (known after apply)
                            }
                        }

                      + secret {
                          + default_mode = (known after apply)
                          + optional     = (known after apply)
                          + secret_name  = (known after apply)

                          + items {
                              + key  = (known after apply)
                              + mode = (known after apply)
                              + path = (known after apply)
                            }
                        }

                      + vsphere_volume {
                          + fs_type     = (known after apply)
                          + volume_path = (known after apply)
                        }
                    }
                }
            }
        }
    }

  # kubernetes_deployment.wordpress_deployment will be created
  + resource "kubernetes_deployment" "wordpress_deployment" {
      + id = (known after apply)

      + metadata {
          + generation       = (known after apply)
          + name             = "wordpress"
          + namespace        = "default"
          + resource_version = (known after apply)
          + self_link        = (known after apply)
          + uid              = (known after apply)
        }

      + spec {
          + min_ready_seconds         = 0
          + paused                    = false
          + progress_deadline_seconds = 600
          + replicas                  = 1
          + revision_history_limit    = 10

          + selector {
              + match_labels = {
                  + "app"  = "wordpress"
                  + "tier" = "frontend"
                }
            }

          + strategy {
              + type = (known after apply)

              + rolling_update {
                  + max_surge       = (known after apply)
                  + max_unavailable = (known after apply)
                }
            }

          + template {
              + metadata {
                  + generation       = (known after apply)
                  + labels           = {
                      + "app"  = "wordpress"
                      + "tier" = "frontend"
                    }
                  + name             = (known after apply)
                  + resource_version = (known after apply)
                  + self_link        = (known after apply)
                  + uid              = (known after apply)
                }

              + spec {
                  + dns_policy                       = "ClusterFirst"
                  + host_ipc                         = false
                  + host_network                     = false
                  + host_pid                         = false
                  + hostname                         = (known after apply)
                  + node_name                        = (known after apply)
                  + restart_policy                   = "Always"
                  + service_account_name             = (known after apply)
                  + share_process_namespace          = false
                  + termination_grace_period_seconds = 30

                  + container {
                      + image                    = "wordpress:latest"
                      + image_pull_policy        = (known after apply)
                      + name                     = "wordpress"
                      + stdin                    = false
                      + stdin_once               = false
                      + termination_message_path = "/dev/termination-log"
                      + tty                      = false

                      + env {
                          + name  = "WORDPRESS_DB_HOST"
                          + value = "wordpress-mysql"
                        }
                      + env {
                          + name  = "WORDPRESS_DB_PASSWORD"
                          + value = "P4sSw0rd0!"
                        }

                      + port {
                          + container_port = 80
                          + name           = "wordpress"
                          + protocol       = "TCP"
                        }

                      + resources {
                          + limits {
                              + cpu    = (known after apply)
                              + memory = (known after apply)
                            }

                          + requests {
                              + cpu    = (known after apply)
                              + memory = (known after apply)
                            }
                        }

                      + volume_mount {
                          + mount_path        = (known after apply)
                          + mount_propagation = (known after apply)
                          + name              = (known after apply)
                          + read_only         = (known after apply)
                          + sub_path          = (known after apply)
                        }
                    }

                  + image_pull_secrets {
                      + name = (known after apply)
                    }

                  + volume {
                      + name = (known after apply)

                      + aws_elastic_block_store {
                          + fs_type   = (known after apply)
                          + partition = (known after apply)
                          + read_only = (known after apply)
                          + volume_id = (known after apply)
                        }

                      + azure_disk {
                          + caching_mode  = (known after apply)
                          + data_disk_uri = (known after apply)
                          + disk_name     = (known after apply)
                          + fs_type       = (known after apply)
                          + read_only     = (known after apply)
                        }

                      + azure_file {
                          + read_only   = (known after apply)
                          + secret_name = (known after apply)
                          + share_name  = (known after apply)
                        }

                      + ceph_fs {
                          + monitors    = (known after apply)
                          + path        = (known after apply)
                          + read_only   = (known after apply)
                          + secret_file = (known after apply)
                          + user        = (known after apply)

                          + secret_ref {
                              + name = (known after apply)
                            }
                        }

                      + cinder {
                          + fs_type   = (known after apply)
                          + read_only = (known after apply)
                          + volume_id = (known after apply)
                        }

                      + config_map {
                          + default_mode = (known after apply)
                          + name         = (known after apply)

                          + items {
                              + key  = (known after apply)
                              + mode = (known after apply)
                              + path = (known after apply)
                            }
                        }

                      + downward_api {
                          + default_mode = (known after apply)

                          + items {
                              + mode = (known after apply)
                              + path = (known after apply)

                              + field_ref {
                                  + api_version = (known after apply)
                                  + field_path  = (known after apply)
                                }

                              + resource_field_ref {
                                  + container_name = (known after apply)
                                  + quantity       = (known after apply)
                                  + resource       = (known after apply)
                                }
                            }
                        }

                      + empty_dir {
                          + medium = (known after apply)
                        }

                      + fc {
                          + fs_type      = (known after apply)
                          + lun          = (known after apply)
                          + read_only    = (known after apply)
                          + target_ww_ns = (known after apply)
                        }

                      + flex_volume {
                          + driver    = (known after apply)
                          + fs_type   = (known after apply)
                          + options   = (known after apply)
                          + read_only = (known after apply)

                          + secret_ref {
                              + name = (known after apply)
                            }
                        }

                      + flocker {
                          + dataset_name = (known after apply)
                          + dataset_uuid = (known after apply)
                        }

                      + gce_persistent_disk {
                          + fs_type   = (known after apply)
                          + partition = (known after apply)
                          + pd_name   = (known after apply)
                          + read_only = (known after apply)
                        }

                      + git_repo {
                          + directory  = (known after apply)
                          + repository = (known after apply)
                          + revision   = (known after apply)
                        }

                      + glusterfs {
                          + endpoints_name = (known after apply)
                          + path           = (known after apply)
                          + read_only      = (known after apply)
                        }

                      + host_path {
                          + path = (known after apply)
                          + type = (known after apply)
                        }

                      + iscsi {
                          + fs_type         = (known after apply)
                          + iqn             = (known after apply)
                          + iscsi_interface = (known after apply)
                          + lun             = (known after apply)
                          + read_only       = (known after apply)
                          + target_portal   = (known after apply)
                        }

                      + local {
                          + path = (known after apply)
                        }

                      + nfs {
                          + path      = (known after apply)
                          + read_only = (known after apply)
                          + server    = (known after apply)
                        }

                      + persistent_volume_claim {
                          + claim_name = (known after apply)
                          + read_only  = (known after apply)
                        }

                      + photon_persistent_disk {
                          + fs_type = (known after apply)
                          + pd_id   = (known after apply)
                        }

                      + quobyte {
                          + group     = (known after apply)
                          + read_only = (known after apply)
                          + registry  = (known after apply)
                          + user      = (known after apply)
                          + volume    = (known after apply)
                        }

                      + rbd {
                          + ceph_monitors = (known after apply)
                          + fs_type       = (known after apply)
                          + keyring       = (known after apply)
                          + rados_user    = (known after apply)
                          + rbd_image     = (known after apply)
                          + rbd_pool      = (known after apply)
                          + read_only     = (known after apply)

                          + secret_ref {
                              + name = (known after apply)
                            }
                        }

                      + secret {
                          + default_mode = (known after apply)
                          + optional     = (known after apply)
                          + secret_name  = (known after apply)

                          + items {
                              + key  = (known after apply)
                              + mode = (known after apply)
                              + path = (known after apply)
                            }
                        }

                      + vsphere_volume {
                          + fs_type     = (known after apply)
                          + volume_path = (known after apply)
                        }
                    }
                }
            }
        }
    }

  # kubernetes_service.mysql_service will be created
  + resource "kubernetes_service" "mysql_service" {
      + id                    = (known after apply)
      + load_balancer_ingress = (known after apply)

      + metadata {
          + generation       = (known after apply)
          + labels           = {
              + "app" = "wordpress"
            }
          + name             = "wordpress-mysql"
          + namespace        = "default"
          + resource_version = (known after apply)
          + self_link        = (known after apply)
          + uid              = (known after apply)
        }

      + spec {
          + cluster_ip                  = (known after apply)
          + external_traffic_policy     = (known after apply)
          + publish_not_ready_addresses = false
          + selector                    = {
              + "app"  = "wordpress"
              + "tier" = "mysql"
            }
          + session_affinity            = "None"
          + type                        = "NodePort"

          + port {
              + node_port   = (known after apply)
              + port        = 3306
              + protocol    = "TCP"
              + target_port = (known after apply)
            }
        }
    }

  # kubernetes_service.wordpress_service will be created
  + resource "kubernetes_service" "wordpress_service" {
      + id                    = (known after apply)
      + load_balancer_ingress = (known after apply)

      + metadata {
          + generation       = (known after apply)
          + labels           = {
              + "app" = "wordpress"
            }
          + name             = "wordpress"
          + namespace        = "default"
          + resource_version = (known after apply)
          + self_link        = (known after apply)
          + uid              = (known after apply)
        }

      + spec {
          + cluster_ip                  = (known after apply)
          + external_traffic_policy     = (known after apply)
          + publish_not_ready_addresses = false
          + selector                    = {
              + "app"  = "wordpress"
              + "tier" = "frontend"
            }
          + session_affinity            = "None"
          + type                        = "NodePort"

          + port {
              + node_port   = 30080
              + port        = 80
              + protocol    = "TCP"
              + target_port = "80"
            }
        }
    }

Plan: 4 to add, 0 to change, 0 to destroy.

Do you want to perform these actions?
  Terraform will perform the actions described above.
  Only 'yes' will be accepted to approve.

  Enter a value: yes

kubernetes_service.wordpress_service: Creating...
kubernetes_service.mysql_service: Creating...
kubernetes_service.wordpress_service: Creation complete after 0s [id=default/wordpress]
kubernetes_service.mysql_service: Creation complete after 0s [id=default/wordpress-mysql]
kubernetes_deployment.wordpress_deployment: Creating...
kubernetes_deployment.mysql_deployment: Creating...
kubernetes_deployment.wordpress_deployment: Still creating... [10s elapsed]
kubernetes_deployment.mysql_deployment: Still creating... [10s elapsed]
kubernetes_deployment.mysql_deployment: Creation complete after 16s [id=default/wordpress-mysql]
kubernetes_deployment.wordpress_deployment: Still creating... [20s elapsed]
kubernetes_deployment.wordpress_deployment: Still creating... [30s elapsed]
kubernetes_deployment.wordpress_deployment: Still creating... [40s elapsed]
kubernetes_deployment.wordpress_deployment: Still creating... [50s elapsed]
kubernetes_deployment.wordpress_deployment: Creation complete after 56s [id=default/wordpress]

Apply complete! Resources: 4 added, 0 changed, 0 destroyed.


master $ kubectl get pods
NAME                               READY   STATUS    RESTARTS   AGE
wordpress-f88975676-7pxm9          1/1     Running   0          2m15s
wordpress-mysql-7b858c6bdc-9rttr   1/1     Running   0          2m15s

master $ kubectl get deploy
NAME              READY   UP-TO-DATE   AVAILABLE   AGE
wordpress         1/1     1            1           2m43s
wordpress-mysql   1/1     1            1           2m43s

master $ kubectl get svc
NAME              TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)          AGE
kubernetes        ClusterIP   10.96.0.1        <none>        443/TCP          36m
wordpress         NodePort    10.108.233.134   <none>        80:30080/TCP     3m22s
wordpress-mysql   NodePort    10.99.214.143    <none>        3306:31416/TCP   3m22s


master $ kubectl describe pod wordpress-mysql-7b858c6bdc-9rttr
Name:               wordpress-mysql-7b858c6bdc-9rttr
Namespace:          default
Priority:           0
PriorityClassName:  <none>
Node:               node01/172.17.0.94
Start Time:         Fri, 13 Dec 2019 09:00:28 +0000
Labels:             app=wordpress
                    pod-template-hash=7b858c6bdc
                    tier=mysql
Annotations:        <none>
Status:             Running
IP:                 10.44.0.2
Controlled By:      ReplicaSet/wordpress-mysql-7b858c6bdc
Containers:
  mysql:
    Container ID:   docker://0c23eb6998bccb43c6ee1a10cd5a57498eb031d9c2407f1f4afe384bc4f2eb23
    Image:          mysql:5.7
    Image ID:       docker-pullable://mysql@sha256:5779c71a4730da36f013a23a437b5831198e68e634575f487d37a0639470e3a8
    Port:           3306/TCP
    Host Port:      0/TCP
    State:          Running
      Started:      Fri, 13 Dec 2019 09:00:42 +0000
    Ready:          True
    Restart Count:  0
    Environment:
      MYSQL_ROOT_PASSWORD:  P4sSw0rd0!
    Mounts:                 <none>
Conditions:
  Type              Status
  Initialized       True
  Ready             True
  ContainersReady   True
  PodScheduled      True
Volumes:            <none>
QoS Class:          BestEffort
Node-Selectors:     <none>
Tolerations:        node.kubernetes.io/not-ready:NoExecute for 300s
                    node.kubernetes.io/unreachable:NoExecute for 300s
Events:
  Type    Reason     Age   From               Message
  ----    ------     ----  ----               -------
  Normal  Scheduled  22m   default-scheduler  Successfully assigned default/wordpress-mysql-7b858c6bdc-9rttr to node01
  Normal  Pulling    22m   kubelet, node01    Pulling image "mysql:5.7"
  Normal  Pulled     22m   kubelet, node01    Successfully pulled image "mysql:5.7"
  Normal  Created    22m   kubelet, node01    Created container mysql
  Normal  Started    22m   kubelet, node01    Started container mysql


master $ kubectl describe pod wordpress-f88975676-7pxm9
Name:               wordpress-f88975676-7pxm9
Namespace:          default
Priority:           0
PriorityClassName:  <none>
Node:               node01/172.17.0.94
Start Time:         Fri, 13 Dec 2019 09:00:28 +0000
Labels:             app=wordpress
                    pod-template-hash=f88975676
                    tier=frontend
Annotations:        <none>
Status:             Running
IP:                 10.44.0.3
Controlled By:      ReplicaSet/wordpress-f88975676
Containers:
  wordpress:
    Container ID:   docker://a09bfa2b23c4343e9001f3d45b5dea67272592abbc1e5d4f99971591fef70359
    Image:          wordpress:latest
    Image ID:       docker-pullable://wordpress@sha256:670136dc1c6b4fe232c126aaa0f25f596bda9696d535ff8ff25f7680235afcce
    Port:           80/TCP
    Host Port:      0/TCP
    State:          Running
      Started:      Fri, 13 Dec 2019 09:01:13 +0000
    Ready:          True
    Restart Count:  0
    Environment:
      WORDPRESS_DB_HOST:      wordpress-mysql
      WORDPRESS_DB_PASSWORD:  P4sSw0rd0!
    Mounts:                   <none>
Conditions:
  Type              Status
  Initialized       True
  Ready             True
  ContainersReady   True
  PodScheduled      True
Volumes:            <none>
QoS Class:          BestEffort
Node-Selectors:     <none>
Tolerations:        node.kubernetes.io/not-ready:NoExecute for 300s
                    node.kubernetes.io/unreachable:NoExecute for 300s
Events:
  Type    Reason     Age   From               Message
  ----    ------     ----  ----               -------
  Normal  Scheduled  23m   default-scheduler  Successfully assigned default/wordpress-f88975676-7pxm9 to node01
  Normal  Pulling    23m   kubelet, node01    Pulling image "wordpress:latest"
  Normal  Pulled     23m   kubelet, node01    Successfully pulled image "wordpress:latest"
  Normal  Created    23m   kubelet, node01    Created container wordpress
  Normal  Started    23m   kubelet, node01    Started container wordpress.
